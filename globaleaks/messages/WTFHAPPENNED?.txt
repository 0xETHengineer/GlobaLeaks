We have now moved to doing all the validation by matching against the know
datatypes contained inside of messages/. This is something that will be
implemented once we actually start having some data. This means that there is
no longer need for the definition of classes for everything we are interested
in validating, but we can just call a function in the same place where the data
is processed.

Here is a copy of what used to be contained in sanitizers and validators:

from sanitzers.py

# Sanitizer goals: every field need to be checked, escaped
# if something is wrong in format, raise an exception

# Sanitizer classes facts:

# . The variables returned from all the following functions,
#   is a dict, because in the next step would be passed as (*arg, **kw)
# . sanitizer is called after the validation, therefore we're
#   guarantee that the fields here analyzed are coherent with the
#  specified API
# . Text would be converted in unicode in this functions
# . Exist some helper function performing the checks, they are
#   private modules implemented in globaleaks.utils.sanitychecks
# . Modules, having a dedicated set of fields, implement their
#   own sanitizer method, globaleaks.utils.modules support in that

class SubmissionSanitizer(object):

    """
    finalize and root actions covered here,
    boolean or int only
    """

class TipSanitizer(object):

    """
    root, pertinence and finalize are covered here,
    because their fields are boolean or int
    """

class ReceiverSanitizer(object):

    """
    all the receiver actions are handler here, but
    maybe the CURD need to be splitted properly
    (and the, sanizer handled with a _HTTPMETHOD selection)
    """
"""
AdminSanitezer has not defaultd, because all
the four action in admin API had a large set of elements
that need to be checked carefully
"""
class AdminSanitizer(object):


from validators.py

"""
Validator perform integrity checks in the submitted field,
and perform every sanity checks in the submitted type
it may perform loggin for specific operation if enabled.

Validator perform integrity check only, not logical checks
that need knowledge of data meaning.

What's validator DO NOT:

. only a receiver can express pertinencies in a Tip,
  if a whistleblower Tip is used to express a pertinency this error
  would be detected and managed by the Tip object.

. not all contexts supports the option for delete a Tip as
  receiver option. This check would be performed by the Tip
  object, also if is a context dependent settings.

validator perform syntax checking, not logical.

Validatator DO:

. Verify that all the fields and the matched arguments
  are coherent with the API-specification
. Perform eventually logging in a specific operations
. Act as blacklisting module if some keywork/behaviour
  would be blocked, or managed in a particular way.

Validator is the first layer of checks after the HTTP
request, after the validator procedure not all the
request may be passed.
"""

"""
    dynamic argument schema:

    def default(*arg, **kw):

    action  = name of the action looked by
    method  = name of the HTTP method used
    uriargs = the regexp matched in the URL, defined in spec.api
    body    = the raw body
"""

