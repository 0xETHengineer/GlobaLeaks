# coding=utf-8
from storm.exceptions import NotOneError
from storm.twisted.transact import transact
# -*- encoding: utf-8 -*-
#
# :authors: Arturo Filast√≤
# :licence: see LICENSE

from storm.locals import Int, Pickle
from storm.locals import Unicode, Bool, DateTime
from storm.locals import ReferenceSet, Reference

from globaleaks.utils import gltime, idops

from globaleaks.models.base import TXModel, ModelError
from globaleaks.models.receiver import Receiver
from globaleaks.models.node import Node
from globaleaks.utils import log


__all__ = [ 'Context', 'ModulesProfiles',
            'AdminStats', 'LocalizedTexts', 'ReceiverContext', 'InvalidContext' ]


class InvalidContext(ModelError):
    ModelError.error_message = "Invalid Context addressed with context_gus"
    ModelError.error_code = 1 # need to be resumed the table and come back in use them
    ModelError.http_status = 500

class ModulesProfiles(TXModel):
    """
    remind: may exists more module profiles, also for the same module, in this
    case, the module_gus variable (generated by idops.random_module_gus) is different
    between them.

    this is a collection of profile, therefore may exists some entry having configuration
    not used in a context, and other entry used.
    The module_gus is addressed in Context.notification_profiles, Context.delivery_profiles
    and Context.inputfilter_chain
    """
    log.debug("[D] %s %s " % (__file__, __name__), "Class ModulesProfiles")
    __storm_table__ = 'modules'

    module_gus = Unicode(primary=True)
    description = Unicode()
    module_name = Unicode()
    module_description = Unicode()

    type = Unicode() # notification | delivery | inputfilter

    admin_fields = Unicode()
    user_fields = Unicode()


class AdminStats(TXModel):
    """
    every entry is the collection of the elements in the last
    node.private_stats_delta (expressed in minutes)
    """
    log.debug("[D] %s %s " % (__file__, __name__), "Class AdminStats")
    __storm_table__ = 'adminstats'

    id = Int(primary=True)
        # XXX: perhaps related to Context.context_gus ?

    receiver_access = Int()
    download = Int()
    submission = Int()
    whistleblower_access = Int()

    download_forbidden = Int()
        # count of the download tried but deny for be expired

    access_forbidden = Int()
    removed_submission = Int()

    """
    This statistics for admininistrator, can be easily expanded, keeping track also which kind of submission
    has been forbidden, expire, created, downloaded, etc. Can be a detailed monitor of the activities.
    """

class LocalizedTexts(TXModel):
    """
    need to be defined an API, that permit the admin, to convert all the description texts and
    localize them
    """
    log.debug("[D] %s %s " % (__file__, __name__), "Class LocalizedTexts")
    __storm_table__ = 'localizedtexts'

    id = Int(primary=True)
    reference = Pickle()
    translated = Pickle()

    """
    need to be defined with the Client and in the API, but most likely would be
    a struct like the POT file, pickled in the database, and managed by administrators input
    """

class ReceiverContext(TXModel):
    log.debug("[D] %s %s " % (__file__, __name__), "Class ReceiverContext")
    __storm_table__ = 'receivers_context'
    __storm_primary__ = "context_gus", "receiver_gus"

    context_gus = Int()
    # holy shit, here receiver_gus is an Int, not a Unicode()/globaleaks uniq string
    receiver_gus = Int()

class Context(TXModel):
    __storm_table__ = 'contexts'

    context_gus = Unicode(primary=True)

    node_id = Int()
    node = Reference(node_id, Node.id)

    name = Unicode()
    description = Unicode()
    fields = Pickle()

    languages_supported = Pickle()

    selectable_receiver = Bool()
    escalation_threshold = Int()

    # to be defined and maybe splitted with
    creation_time = DateTime()
    last_activity = DateTime()
    # last_update and last_activity

    # to be implemented in REST / dict
    tip_max_access = Int()
    tip_timetolive = Int()
    folder_max_download = Int()
    notification_profiles = Pickle()
    delivery_profiles = Pickle()
    inputfilter_chain = Pickle()
    # to be implemented in REST / dict

    @transact
    def new(self, context_dict):
        """
        @param context_dict: a dictionary containing the expected field of a context,
                is called and define as contextDescriptionDict
        @return: context_gus, the universally unique identifier of the context
        """
        log.debug("[D] %s %s " % (__file__, __name__), "Context new", context_dict)

        store = self.getStore('context new')

        context = Context()

        context.context_gus = idops.random_context_gus()
        context.node_id = 1

        context.creation_date = gltime.utcDateNow()
        context.update_date = gltime.utcDateNow()

        context.name = context_dict["name"]
        context.fields = context_dict["fields"]
        context.description = context_dict["description"]
        context.selectable_receiver = context_dict["selectable_receiver"]
        context.escalation_threshold = context_dict["escalation_threshold"]
            # this line has not an int() because when validation works, will check
            # if the integer is present or not.

        # context.languages_supported = context_dict["languages_supported"]
        # this is not taked by the dict, is generated by the receivers
        # declared knowledge

        # Receiver is not added here

        store.add(context)
        # log.info("Created context %s at the %s" % (context.name, context.creation_date) )
        store.commit()
        store.close()

        # return context_dict
        return context.context_gus

    @transact
    def update(self, context_gus, context_dict):
        """
        @param context_gus: the universal unique identifier
        @param context_dict: the information fields that need to be update, here is
            supported to be already validated, sanitized and logically verified
            by handlers
        @return:
        """
        log.debug("[D] %s %s " % (__file__, __name__), "Context update of", context_gus)
        store = self.getStore('context update')

        try:
            requested_c = store.find(Context, Context.context_gus == context_gus).one()
        except NotOneError:
            log.debug("[Error] looked for .one() fail with context_gus %s " % context_gus)
            store.close()
            raise InvalidContext
            print "me so a prosegui"

        requested_c.name = context_dict['name']
        requested_c.fields = context_dict['fields']
        requested_c.description = context_dict['description']
        requested_c.selectable_receiver = context_dict['selectable_receiver']
        requested_c.escalation_threshold = context_dict['escalation_threshold']
        # this line has not an int() because when validation works, will check
        # if the integer is present or not.

        # remind: 'receivers' and 'language supported' are updated in other
        # interfaces

        # TODO: last_activity need to be update, perhaps in a separated interface
        #       easy to be called by other updating methods
        store.commit()
        # log.info("Updated context %s, created in %s" % (requested_c.name, requested_c.creation_date) )
        store.close()

    @transact
    def delete_context(self, context_gus):
        """
        @param context_gus: the universal unique identifier of the context
        @return: None if is deleted correctly, or raise an exception if something is wrong.
        """
        log.debug("[D] %s %s " % (__file__, __name__), "Context update of", context_gus)

        store = self.getStore('context delete')

        try:
            requested_c = store.find(Context, Context.context_gus == context_gus).one()
        except NotOneError:
            log.debug("[Error] looked for .one() fail with context_gus %s " % context_gus)
            store.close()
            raise InvalidContext

        # log.info("Deleted context %s, created in %s" % (requested_c.name, requested_c.creation_date) )
        store.remove(requested_c)
        store.commit()
        store.close()


    @transact
    def get_single_context(self, context_gus):
        """
        @param context_gus: UUID of the contexts
        @return: the contextDescriptionDict requested, or an exception if do not exists
        """

        store = self.getStore('context get_single')

        try:
            requested_c = store.find(Context, Context.context_gus == context_gus).one()
        except NotOneError:
            log.debug("[Error] looked for .one() fail with context_gus %s " % context_gus)
            store.close()
            raise InvalidContext

        # This is BAD! but actually we have not yet re-defined a policy to manage
        # REST answers
        retContext = {'context_gus' : requested_c.context_gus,
                      'name': requested_c.name,
                      'description' : requested_c.description,
                      'selectable_receiver' : requested_c.selectable_receiver,
                      'fields' : requested_c.fields,
                      'escalation_threshold' : requested_c.escalation_threshold }
        # This is missing of all the other need to be implemented fields

        store.close()
        return retContext

    @transact
    def get_all_contexts(self):
        """
        @return: an array containing all contextDescriptionDict
        """
        log.debug("[D] %s %s " % (__file__, __name__), "Context list_description_dicts")

        store = self.getStore('context get_all')
        dicts = []
        result = store.find(Context)
        for context in result:
            dd = context.generate_description_dict(context.receiver_dicts())
            dicts.append(dd)

        store.commit()
        store.close()
        return dicts

    # under review
    def generate_description_dict(self, receivers):

        log.debug("[D] %s %s " % (__file__, __name__), "Context generate_description_dict")

        description_dict = {"context_gus": self.context_gus,
                            "name": self.name,
                            "description": self.description,
                            "selectable_receiver": self.selectable_receiver,
                            "escalation_threshold": self.escalation_threshold,
                            "languages_supported": self.languages_supported,
                            "fields": self.fields,
                            "receivers": receivers
        }
        return description_dict


    # under review
    def receiver_dicts(self):
        log.debug("[D] %s %s " % (__file__, __name__), "Context receiver_dicts")

        receiver_dicts = []
        for receiver in self.receivers:
            receiver_dict = {"receiver_gus": receiver.receiver_gus,
                    "can_delete_submission": receiver.can_delete_submission,
                    "can_postpone_expiration": receiver.can_postpone_expiration,
                    "can_configure_notification": receiver.can_configure_notification,
                    "can_configure_delivery": receiver.can_configure_delivery,
                    "can_trigger_escalation": receiver.can_trigger_escalation,
                    "name": receiver.name,
                    "description": receiver.description,

                    # one language is the default
                    "languages_supported": receiver.languages_supported
            }
            receiver_dicts.append(receiver_dict)
        return receiver_dicts


    # under review
    def create_receiver_tips(self, internaltip):
        log.debug("[D] %s %s " % (__file__, __name__), "Context create_receiver_tips", internaltip)

        receiver_tips = []
        for receiver in self.receivers:
            from globaleaks.models.tip import ReceiverTip
            receiver_tip = ReceiverTip()
            receiver_tip.new(internaltip.internaltip_id)
            receiver_tips.append(receiver_tip)
        return receiver_tips

    @transact
    def add_receiver(self, context_gus, receiver_gus):
        log.debug("[D] %s %s " % (__file__, __name__), "Context add_receiver")

        store = self.getStore('add_receiver')

        receiver = store.find(Receiver,
                        Receiver.receiver_gus==receiver_gus).one()
        context = store.find(Context,
                        Context.context_gus==context_gus).one()

        context.receivers.add(receiver)

        store.commit()
        store.close()

Context.receivers = ReferenceSet(Context.context_gus,
                             ReceiverContext.context_gus,
                             ReceiverContext.receiver_gus,
                             Receiver.receiver_gus)


